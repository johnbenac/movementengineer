# Movement dataset file guidelines

This repository lets you spread a single movement across many `*-data.js` files (even multiple files per collection like claims or rules) while keeping loading predictable. Use this guide to structure atomic, inspectable datasets.

## Core behaviors to rely on
- Every file under `movements/` that ends with `-data.js` is discovered and loaded (browser and Node) via the manifest generated by `scripts/generate-movement-manifest.js`.
- During load, each dataset object is normalized to contain all collections and then concatenated in order, so multiple files for the same movement merge into a single snapshot. Maintain unique IDs to avoid collisions.
- Browser loading is instrumented: the manifest tracks whether each file registered exactly one dataset and will raise a fatal banner if a file fails or registers none/multiple.

## Authoring checklist
- **File naming**: Use descriptive `*-data.js` filenames; keep one dataset object per file. Place files anywhere under a movement folder (e.g., `movements/<movement-id>/claims/claim-alpha-data.js`).
- **Exports**: Each file should `module.exports = { ... }` (Node) or `window.movementDatasets.push({ ... })` (browser); prefer CommonJS style so Node tests and the manifest loader both work.
- **IDs**: Keep IDs globally unique across files. If you fork or duplicate snippets, regenerate IDs to prevent merged-array conflicts.
- **Movement linkage**: Every record must set `movementId` to the owning movement’s ID; this is the glue when merging multiple files for one movement.
- **Collection defaults**: Unused collections can be omitted; the loader fills them as empty arrays. Populate only what the file needs (e.g., just `claims` or `rules`).
- **Cross-file references**: You can reference IDs defined in other files (claims → rules, rules → entities, etc.). Ensure referenced IDs exist somewhere in the movement set.
- **Sources and texts**: Shared `sources` or `texts` can live in their own files and be reused by claims/rules via IDs, enabling “molecular” reuse.
- **Tags and notes**: Keep tagging/notes consistent across files to ease diffing and review.

## Recommended directory layouts
- **Per-collection folders** to emphasize atomicity:
  - `movements/<movement-id>/claims/<topic>-claim-data.js`
  - `movements/<movement-id>/rules/<area>-rule-data.js`
  - `movements/<movement-id>/entities/<kind>-entity-data.js`
- **Scenario-focused bundles** when grouping by theme or event:
  - `movements/<movement-id>/events/<season>/<event-id>-data.js`
  - `movements/<movement-id>/texts/<work-id>-data.js`
- Keep a small `.../base-data.js` file with the movement record, baseline texts/sources, and any IDs commonly referenced elsewhere.

## Manifest regeneration
- After adding, renaming, or relocating any `*-data.js` file, rerun:
  - `node scripts/generate-movement-manifest.js`
- Commit the updated `movements/manifest.js` so the browser loads the new fragments.

## Validation tips
- **Node load check**: `node -e "require('./movement-data')"` will throw if any dataset fails to load or exports a non-object.
- **Browser fatal banner**: When running the app, a red banner appears if a dataset script fails, registers zero datasets, or registers multiple datasets. Fix errors per file until the banner disappears.
- **Diff hygiene**: Because each file carries a single dataset, reviewers can diff claims/rules in isolation without scanning unrelated collections.

By following these practices, movement engineers can atomize movement content across many files while preserving predictable loading, reviewability, and cross-file linkage.
